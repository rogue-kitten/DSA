link to problem -> https://codeforces.com/problemset/problem/1225/C

## Approach
```
Suppose we want to represent ğ‘› as the sum of ğ‘˜ ğ‘-binary numbers. 
We must have ğ‘›=âˆ‘ğ‘˜ğ‘–=1(2ğ‘¥ğ‘–+ğ‘) for a suitable choice of ğ‘¥1,â€¦,ğ‘¥ğ‘˜. 
Moving all ğ‘'s to the left-hand side, we must have ğ‘›âˆ’ğ‘˜ğ‘=âˆ‘ğ‘˜ğ‘–=12ğ‘¥ğ‘–. In particular, ğ‘›âˆ’ğ‘˜ğ‘ has to be at least ğ‘˜.

Consider the binary representation of ğ‘›âˆ’ğ‘˜ğ‘. If it has more than ğ‘˜ bits equal to 1, there is no way we 
can split it into ğ‘˜ powers of two. Otherwise, we can start by taking the binary representation, 
and if it contains less than ğ‘˜ powers, we can always split larger powers into two smaller ones.
```

## Code
```cpp
#include<bits/stdc++.h>

using namespace std;
#define vi vector<int>
#define vvi vector<vector<int>>
#define printall(a) for(auto i : a) cout << i << " "
#define print(a) cout << a << endl

int setBits(int n){
	int count = 0;
	while(n){
		n &= (n - 1);
		count++;
	}
	return count;
}

int main(){

	int n, p;
	cin >> n >> p;

	if(p == 0){
		print(setBits(n));
		return 0;
	}

	int i = 1;
	while(n > 0){
		n -= p;
		if(n < i) // n - kp should atleast be equal to k
			break;
		if(i >= setBits(n))
			break;
		i++;
	}
	if(n < i)
		print(-1);
	else
		print(i);
}
```
